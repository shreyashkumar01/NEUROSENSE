-- NeuroSense Production Database Schema
-- Single Source of Truth

-- 1. Users Table (Core Registry)
CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password TEXT,  -- Made nullable for OAuth users
    role TEXT NOT NULL CHECK (role IN ('PATIENT', 'DOCTOR')),
    phone TEXT,
    avatar_url TEXT,
    auth_provider TEXT DEFAULT 'email',  -- 'email' or 'google'
    start_date TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- SAFETY: Ensure new columns exist even if table was already created
DO $$
BEGIN
    ALTER TABLE users ADD COLUMN IF NOT EXISTS phone TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar_url TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS auth_provider TEXT DEFAULT 'email';
    ALTER TABLE users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP;
    
    -- Make password nullable for OAuth users
    ALTER TABLE users ALTER COLUMN password DROP NOT NULL;
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'Column already exists in users.';
END $$;

-- 2. New Profile Tables (Separated by Role)
CREATE TABLE IF NOT EXISTS patient_profiles (
    user_id TEXT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    diagnosis TEXT,
    case_id TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS doctor_profiles (
    user_id TEXT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    license_id TEXT UNIQUE,
    specialty TEXT,
    experience_years INTEGER,
    bio TEXT,
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- 3. Sessions & Connections
CREATE TABLE IF NOT EXISTS sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    patient_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('BODY', 'BRAIN', 'SPEECH', 'MENTAL')),
    exercise_name TEXT,
    score INTEGER NOT NULL CHECK (score BETWEEN 0 AND 100),
    metadata JSONB DEFAULT '{}'::jsonb,
    feedback TEXT
);

CREATE TABLE IF NOT EXISTS connections (
    id TEXT PRIMARY KEY,
    patient_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    doctor_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status TEXT NOT NULL CHECK (status IN ('IDLE', 'PENDING', 'CONNECTED')),
    timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    UNIQUE(patient_id, doctor_id)
);

-- 4. AUTO-MIGRATION LOGIC (Preserves Data)
-- This block moves data from the old 'profiles' table if it exists
DO $$
BEGIN
    IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'profiles') THEN
        -- Migrate Patients
        INSERT INTO patient_profiles (user_id, diagnosis, case_id)
        SELECT user_id, diagnosis, case_id FROM profiles
        WHERE diagnosis IS NOT NULL OR case_id IS NOT NULL
        ON CONFLICT (user_id) DO NOTHING;

        -- Migrate Doctors
        INSERT INTO doctor_profiles (user_id, license_id, is_verified)
        SELECT user_id, license_id, is_verified FROM profiles
        WHERE license_id IS NOT NULL
        ON CONFLICT (user_id) DO NOTHING;
    END IF;
END $$;

-- 5. CLEANUP (Drop old table after migration)
-- Only run this if you are sure migration succeeded. 
-- Uncomment the next line to enable auto-deletion of the old table.
-- DROP TABLE IF EXISTS profiles;

-- 6. Row-Level Security (RLS) policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE patient_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE doctor_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE connections ENABLE ROW LEVEL SECURITY;

-- Policy Definitions (Simplified for Production)
-- Users
DROP POLICY IF EXISTS "Public registration" ON users;
CREATE POLICY "Public registration" ON users FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "User read own" ON users;
CREATE POLICY "User read own" ON users FOR SELECT USING (true);

DROP POLICY IF EXISTS "User update own" ON users;
CREATE POLICY "User update own" ON users FOR UPDATE USING (true);

-- Patient Profiles
DROP POLICY IF EXISTS "Patient create profile" ON patient_profiles;
CREATE POLICY "Patient create profile" ON patient_profiles FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Read patient profiles" ON patient_profiles;
CREATE POLICY "Read patient profiles" ON patient_profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Patient update own" ON patient_profiles;
CREATE POLICY "Patient update own" ON patient_profiles FOR UPDATE USING (true);

-- Doctor Profiles
DROP POLICY IF EXISTS "Doctor create profile" ON doctor_profiles;
CREATE POLICY "Doctor create profile" ON doctor_profiles FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Read doctor profiles" ON doctor_profiles;
CREATE POLICY "Read doctor profiles" ON doctor_profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Doctor update own" ON doctor_profiles;
CREATE POLICY "Doctor update own" ON doctor_profiles FOR UPDATE USING (true);

-- Sessions & Connections
DROP POLICY IF EXISTS "Session insert" ON sessions;
CREATE POLICY "Session insert" ON sessions FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Session read" ON sessions;
CREATE POLICY "Session read" ON sessions FOR SELECT USING (true);

DROP POLICY IF EXISTS "Connection insert" ON connections;
CREATE POLICY "Connection insert" ON connections FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "Connection read" ON connections;
CREATE POLICY "Connection read" ON connections FOR SELECT USING (true);

DROP POLICY IF EXISTS "Connection update" ON connections;
CREATE POLICY "Connection update" ON connections FOR UPDATE USING (true);

-- 7. Realtime Triggers for updated_at
CREATE OR REPLACE FUNCTION update_timestamp() RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

DROP TRIGGER IF EXISTS update_users_timestamp ON users;
CREATE TRIGGER update_users_timestamp BEFORE UPDATE ON users FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

DROP TRIGGER IF EXISTS update_patients_timestamp ON patient_profiles;
CREATE TRIGGER update_patients_timestamp BEFORE UPDATE ON patient_profiles FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

DROP TRIGGER IF EXISTS update_doctors_timestamp ON doctor_profiles;
CREATE TRIGGER update_doctors_timestamp BEFORE UPDATE ON doctor_profiles FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

-- 7.1 MIGRATION: Add exercise_name and metadata to sessions
DO $$
BEGIN
    ALTER TABLE sessions ADD COLUMN IF NOT EXISTS exercise_name TEXT;
    ALTER TABLE sessions ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}'::jsonb;
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'Column already exists in sessions.';
END $$;

-- 7.2 MIGRATION: Add specialty, experience, and bio to doctors
DO $$
BEGIN
    ALTER TABLE doctor_profiles ADD COLUMN IF NOT EXISTS specialty TEXT;
    ALTER TABLE doctor_profiles ADD COLUMN IF NOT EXISTS experience_years INTEGER;
    ALTER TABLE doctor_profiles ADD COLUMN IF NOT EXISTS bio TEXT;
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'Column already exists in doctor_profiles.';
END $$;

-- 7.3 MIGRATION: Create messages table with update tracking
CREATE TABLE IF NOT EXISTS messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  receiver_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  is_read BOOLEAN DEFAULT FALSE,
  is_edited BOOLEAN DEFAULT FALSE,
  deleted_for_sender BOOLEAN DEFAULT FALSE,
  deleted_for_receiver BOOLEAN DEFAULT FALSE,
  timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Trigger Function for auto-updating updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Re-set Trigger (Drop first for idempotency)
DROP TRIGGER IF EXISTS update_messages_updated_at ON messages;
CREATE TRIGGER update_messages_updated_at
    BEFORE UPDATE ON messages
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS & Security Policies
-- Force enable RLS
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Clean existing policies & set Full Access for development
DO $$ 
DECLARE pol record;
BEGIN 
    FOR pol IN SELECT policyname FROM pg_policies WHERE tablename = 'messages' 
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON messages', pol.policyname);
    END LOOP;
END $$;

CREATE POLICY "Messages full access"
    ON messages FOR ALL
    USING (true)
    WITH CHECK (true);

-- 7.4 PERFORMANCE: Indices
CREATE INDEX IF NOT EXISTS idx_messages_sender ON messages (sender_id);
CREATE INDEX IF NOT EXISTS idx_messages_receiver ON messages (receiver_id);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages (timestamp DESC);


-- 8. STORAGE CONFIGURATION (Avatars)
-- Create a public bucket for profile images
INSERT INTO storage.buckets (id, name, public) 
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- Storage Security Policies
-- Allow public access to view avatars
DROP POLICY IF EXISTS "Avatar images are publicly accessible" ON storage.objects;
CREATE POLICY "Avatar images are publicly accessible"
  ON storage.objects FOR SELECT
  USING ( bucket_id = 'avatars' );

-- Allow authenticated users to upload avatars
DROP POLICY IF EXISTS "Anyone can upload an avatar" ON storage.objects;
CREATE POLICY "Anyone can upload an avatar"
  ON storage.objects FOR INSERT
  WITH CHECK ( bucket_id = 'avatars' );

-- Allow users to update their own avatars (optional, depends on file naming strategy)
DROP POLICY IF EXISTS "Users can update own avatar" ON storage.objects;
CREATE POLICY "Users can update own avatar"
  ON storage.objects FOR UPDATE
  USING ( bucket_id = 'avatars' );
-- 7. DATA SEEDING / MIGRATION FIXES
-- Ensure all existing doctors have profiles and are verified
INSERT INTO doctor_profiles (user_id, is_verified)
SELECT id, TRUE
FROM users
WHERE role = 'DOCTOR'
ON CONFLICT (user_id) DO UPDATE SET is_verified = TRUE;

-- 8. CALLS (Video/Audio Call Logs)
CREATE TABLE IF NOT EXISTS calls (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    caller_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    receiver_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    started_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    ended_at TIMESTAMPTZ,
    status TEXT NOT NULL CHECK (status IN ('MISSED', 'COMPLETED', 'REJECTED', 'BUSY')),
    type TEXT DEFAULT 'VIDEO' CHECK (type IN ('VIDEO', 'AUDIO')),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Index for call history
CREATE INDEX IF NOT EXISTS idx_calls_caller ON calls (caller_id);
CREATE INDEX IF NOT EXISTS idx_calls_receiver ON calls (receiver_id);
CREATE INDEX IF NOT EXISTS idx_calls_timestamp ON calls (started_at DESC);

-- 9. MIGRATION: Update messages table for Soft Delete & Editing
DO $$
BEGIN
    ALTER TABLE messages ADD COLUMN IF NOT EXISTS is_edited BOOLEAN DEFAULT FALSE;
    ALTER TABLE messages ADD COLUMN IF NOT EXISTS deleted_for_sender BOOLEAN DEFAULT FALSE;
    ALTER TABLE messages ADD COLUMN IF NOT EXISTS deleted_for_receiver BOOLEAN DEFAULT FALSE;
EXCEPTION
    WHEN duplicate_column THEN RAISE NOTICE 'Column already exists in messages.';
END $$;
